---
name: Auto-Merge PRs

# Automatically merge pull requests when:
# - All required checks pass
# - PR is approved
# - PR has 'auto-merge' label
# - No merge conflicts

on:
  pull_request:
    types: [labeled, unlabeled, synchronize, reopened, ready_for_review]
  pull_request_review:
    types: [submitted]
  check_suite:
    types: [completed]

permissions:
  contents: write
  pull-requests: write
  checks: read

jobs:
  auto-merge:
    runs-on: ubuntu-latest
    if: github.event.pull_request.draft == false
    
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Check auto-merge eligibility
        id: check-eligibility
        uses: actions/github-script@v7
        with:
          script: |
            const { data: pr } = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });
            
            console.log('PR State:', pr.state);
            console.log('Mergeable:', pr.mergeable);
            console.log('Mergeable State:', pr.mergeable_state);
            console.log('Labels:', pr.labels.map(l => l.name).join(', '));
            
            // Check if PR has auto-merge label
            const hasAutoMergeLabel = pr.labels.some(label => 
              label.name === 'auto-merge'
            );
            
            if (!hasAutoMergeLabel) {
              console.log('❌ No auto-merge label');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Missing auto-merge label');
              return;
            }
            
            // Check if PR is mergeable
            if (pr.mergeable === false) {
              console.log('❌ PR has merge conflicts');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Merge conflicts detected');
              return;
            }
            
            // Check if PR is in open state
            if (pr.state !== 'open') {
              console.log('❌ PR is not open');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'PR is not open');
              return;
            }
            
            // Get reviews
            const { data: reviews } = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number,
            });
            
            // Check for approvals
            const approvedReviews = reviews.filter(review => 
              review.state === 'APPROVED'
            );
            
            const requestedChanges = reviews.filter(review => 
              review.state === 'CHANGES_REQUESTED'
            );
            
            console.log('Approved reviews:', approvedReviews.length);
            console.log('Changes requested:', requestedChanges.length);
            
            if (requestedChanges.length > 0) {
              console.log('❌ Changes requested');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Changes requested');
              return;
            }
            
            if (approvedReviews.length === 0) {
              console.log('❌ No approvals yet');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'No approvals');
              return;
            }
            
            // Check status checks
            const { data: checkRuns } = await github.rest.checks.listForRef({
              owner: context.repo.owner,
              repo: context.repo.repo,
              ref: pr.head.sha,
            });
            
            console.log('Total check runs:', checkRuns.check_runs.length);
            
            const failedChecks = checkRuns.check_runs.filter(check => 
              check.conclusion === 'failure' || check.conclusion === 'cancelled'
            );
            
            const pendingChecks = checkRuns.check_runs.filter(check => 
              check.status !== 'completed'
            );
            
            console.log('Failed checks:', failedChecks.length);
            console.log('Pending checks:', pendingChecks.length);
            
            if (failedChecks.length > 0) {
              console.log('❌ Failed checks detected');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Failed checks');
              return;
            }
            
            if (pendingChecks.length > 0) {
              console.log('⏳ Checks still running');
              core.setOutput('eligible', 'false');
              core.setOutput('reason', 'Checks pending');
              return;
            }
            
            console.log('✅ Eligible for auto-merge');
            core.setOutput('eligible', 'true');
            core.setOutput('reason', 'All conditions met');

      - name: Wait for checks to complete
        if: steps.check-eligibility.outputs.eligible == 'true'
        run: |
          echo "⏳ Waiting 10 seconds to ensure all checks are complete..."
          sleep 10

      - name: Enable auto-merge
        if: steps.check-eligibility.outputs.eligible == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            try {
              // Enable auto-merge with squash strategy
              const result = await github.graphql(`
                mutation EnableAutoMerge($pullRequestId: ID!, $mergeMethod: PullRequestMergeMethod!) {
                  enablePullRequestAutoMerge(input: {
                    pullRequestId: $pullRequestId,
                    mergeMethod: $mergeMethod
                  }) {
                    pullRequest {
                      autoMergeRequest {
                        enabledAt
                      }
                    }
                  }
                }
              `, {
                pullRequestId: context.payload.pull_request.node_id,
                mergeMethod: 'SQUASH'
              });
              
              console.log('✅ Auto-merge enabled');
              
              // Add comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.payload.pull_request.number,
                body: `🤖 **Auto-merge enabled**\n\n` +
                      `This PR will be automatically merged when all conditions are met:\n` +
                      `- ✅ All checks passing\n` +
                      `- ✅ Approved\n` +
                      `- ✅ No merge conflicts\n` +
                      `- ✅ Auto-merge label present\n\n` +
                      `Merge method: **Squash and merge**\n\n` +
                      `_Automated by GitHub Actions_`
              });
              
            } catch (error) {
              console.error('Failed to enable auto-merge:', error);
              
              // Fallback: Try direct merge
              console.log('Attempting direct merge...');
              try {
                await github.rest.pulls.merge({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: context.payload.pull_request.number,
                  merge_method: 'squash',
                  commit_title: context.payload.pull_request.title,
                  commit_message: 'Auto-merged by GitHub Actions'
                });
                
                console.log('✅ Successfully merged');
                
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.payload.pull_request.number,
                  body: `✅ **Auto-merged successfully**\n\n` +
                        `This PR was automatically merged using squash and merge.\n\n` +
                        `_Automated by GitHub Actions_`
                });
              } catch (mergeError) {
                console.error('Failed to merge:', mergeError);
                throw mergeError;
              }
            }

      - name: Add ineligibility comment
        if: steps.check-eligibility.outputs.eligible == 'false'
        uses: actions/github-script@v7
        with:
          script: |
            const reason = '${{ steps.check-eligibility.outputs.reason }}';
            
            // Only add comment if reason is actionable
            if (['Missing auto-merge label', 'No approvals'].includes(reason)) {
              return; // Don't spam with these common states
            }
            
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `⏸️ **Auto-merge paused**\n\n` +
                    `Reason: ${reason}\n\n` +
                    `Auto-merge will proceed when this is resolved.\n\n` +
                    `_Automated by GitHub Actions_`
            });

      - name: Summary
        if: always()
        run: |
          echo "### Auto-Merge Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**PR:** #${{ github.event.pull_request.number }}" >> $GITHUB_STEP_SUMMARY
          echo "**Title:** ${{ github.event.pull_request.title }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.check-eligibility.outputs.eligible }}" = "true" ]; then
            echo "✅ **Auto-merge enabled**" >> $GITHUB_STEP_SUMMARY
            echo "All conditions met - PR will merge automatically" >> $GITHUB_STEP_SUMMARY
          else
            echo "⏸️ **Auto-merge not eligible**" >> $GITHUB_STEP_SUMMARY
            echo "Reason: ${{ steps.check-eligibility.outputs.reason }}" >> $GITHUB_STEP_SUMMARY
          fi
